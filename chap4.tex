\chapter{特征环(Proper Loops)}

上一章，我们介绍了基本环的概念，并且指出，基本环已经足以完成回答集的求解。
本章，我们将进一步指出，并非所有的基本环对于回答集的求解都是必须的，同时，提出了特征环的概念。
本章分别从正规逻辑程序和析取逻辑程序的角度介绍特征环，基于特征环的概念，我们还提出了$HPF$(Head-Proper-loop-Free)程序。
针对识别特征环的时间代价高的问题，我们提出了弱特征环和$HWPF$(Head-Weak-Proper-loop-Free)程序的概念。

\section{正规逻辑程序的特征环}

本节，我们将针对正规逻辑程序，提出特征环的概念，并给出对应的识别算法。

\subsection{特征环的定义}

给定正规逻辑程序$P$，$L$为$P$中的环。用$RLF(L,P)$表示以下的蕴含式：
\begin{equation}
\bigwedge_{r \in head(R^-(L))} p \supset \bigvee_{r \in R^-(L)} body(r) 
\end{equation}

特别地，如果$R^-(L)=\emptyset$，则：
\begin{equation}
\bigwedge_{p \in L} p \supset \bot
\end{equation}

显然，$RLF(L,P)$是$LF(L,P)$的一个特殊情况。
\begin{corollary}\label{chap4_corollary_nlp_clf}
给定正规逻辑程序$P$，$L_1$和$L_2$为$P$的环。如果$R^-(L_1) \ne \emptyset$，$R^-(L_1) \\\subseteq R^-(L_2)$，那么$RLF(L_1,P) \supset RLF(L_2,P)$。
\end{corollary}
\begin{proof}
记$A=\bigwedge_{p \in head(R^-(L_1))} p$，$B=\bigvee_{p \in R^-(r)} body(r)$，$C=\bigwedge_{p \in head(R^-(L_2))} p$，\\
$D=\bigvee_{p \in R^-(L_2)} body(r)$，则：
\begin{eqnarray*}
&& RLF(L_1,P) \supset RLF(L_2,P)\\
&& \Leftrightarrow (A \rightarrow B) \rightarrow (C \rightarrow D)\\
&& \Leftrightarrow (\neg A \vee B) \rightarrow (\neg C \vee D)\\
&& \Leftrightarrow (A \wedge \neg B) \vee (\neg C \vee D)\\
&& \Leftrightarrow (A \vee \neg C \vee D) \wedge (\neg B \vee \neg C \vee D)
\end{eqnarray*}	

另一方面，由$R^-(L_1) \subseteq R^-(L_2)$，得：$\bigwedge_{p \in head(R^-(L_1))} p \leftarrow  \bigwedge_{p \in head(R^-(L_2))} p$，即$C \rightarrow A$为真。
由$R^-(L_1) \subseteq R^-(L_2)$，得：$\bigvee_{p \in R^-(r)} body(r) \rightarrow \bigvee_{p \in R^-(L_2)} body(r)$，即$B \rightarrow D$为真。所以有：
\begin{eqnarray*}
&& true \wedge true\\
&& \Leftrightarrow (C \rightarrow A) \wedge (B \rightarrow D)\\
&& \Leftrightarrow (\neg C \vee A) \wedge (\neg B \vee D)\\
&& \Leftrightarrow (\neg C \vee A \vee D) \wedge (\neg C \vee \neg B \vee D)
\end{eqnarray*}

由于对于$p \rightarrow q$为真，若$p$为真，则$q$为真，所以得出$RLF(L_1,P) \supset RLF(L_2,P)$\\
为真。\quad
\end{proof}

基于推论\ref{chap4_corollary_nlp_clf}，我们可以给出一种新的环(特征环)的定义。
\begin{definition}[正规逻辑程序的特征环]\label{chap4_definition_nlp_properloop}
给定正规逻辑程序$P$，$L$为$P$的环。我们称$L$为$P$的特征环，如果不存在$P$其他环$L'$，使得$L' \subset L$，$R^-(L') \subseteq R^-(L)$或者$R^-(L') \ne \emptyset$，$R^-(L') \subset R^-(L)$。
\end{definition}
\begin{theorem}\label{chap4_theorem_eq4}
给定正规逻辑程序$P$和原子集合$S$，如果$S$满足$P$，那么以下结论和定理\ref{chap2_theorem_eq1}、定理\ref{chap2_theorem_eq2}以及定理\ref{chap3_theorem_eq3}都是等价的：
\begin{enumerate}
	\item 对于$P$中任意特征环$L$，$S$满足$RLF(L,P)$；
	\item 对于$P$中任意特征环$L$，$S$满足$DLF(L,P)$；
\end{enumerate}
\end{theorem}
\begin{example}
考虑例\ref{chap2_program_p1}的程序$P_1$，由于$R^-(\{p,r\})=\{p \leftarrow .,\ r \leftarrow q.\}$，$R^-(\{p\})=\{p \leftarrow .,\ p \leftarrow r.\}$，$R^-(\{p,q,r\})=\{p \leftarrow .\}$，所以$\{p,r\}$和$\{p\}$都不是特征环。
由于$R^-(\{r\})=\{r \leftarrow p.\ r \leftarrow q.\}$，$R^-(\{q,r\})=\{r \leftarrow p.\}$，所以$\{r\}$也不是特征环。因此，$P_1$的特征环只有$\{q\},\{r,q\},\{p,r,q\}$。
\end{example}

给定正规逻辑程序$P$，$L$为$P$的环。如果$L$的特征环，那么$L$同时也是基本环，反过来则不成立。
对于基本环$L$，如果不存在其他基本环$L'$，使得$R^-(L') \ne \emptyset$且$R^-(L') \subset R^-(L)$，基本环$L$才会是特征环。
需要注意的是，这里并没有规定$L'$是$L$的子集，所以需要检查的$L'$的可能非常多。
不过，我们可以加入额外的条件，限制$L'$的范围。

\begin{definition}[正规逻辑程序在原子集合下的特征环]\label{chap4_definition_nlp_properloop_set}
给定正规逻辑程序$P$和原子集合$S$，$L$是$P$的环。
我们称$L$是$P$在$S$下的特征环，如果$L \subseteq S$，且不存在其他环$L' \subseteq S$，使得$L' \subset L$，$R^-(L') \subseteq R^-(L)$或者$R^-(L') \ne \emptyset$，$R^-(L') \subset R^-(L)$。
\end{definition}

\subsection{特征环的识别}

下面，我们将介绍特征环的识别算法。

给定正规逻辑程序$P$，原子集合$S$，$L$为$P$中的环。记$P$的正依赖图$G_P$中，只含$S$的子图为$G_P^S$。
首先，算法\ref{algo_ProperLoop}找出$G_P^S$的所有强连通分量的集合$SCC$。对于每个强连通分量$C \in SCC$：

\begin{enumerate}
	\item $C \subset L$且$R^-(C) \subseteq R^-(L)$，此时符合定义\ref{chap4_definition_nlp_properloop}的第一种情况，返回$C$，表示$C$使得$L$不是特征环；
	\item $R^-(C) \ne \emptyset$且$R^-(C) \subset R^-(L)$，此时符合定义\ref{chap4_definition_nlp_properloop}的第二种情况，返回$C$，表示$C$使得$L$不是特征环；
	\item $R^-(C)=\emptyset$，此时$C$对$L$没有影响，但是，$C$的子环则有可能使得$L$不是特征环。所以这种情况，我们将删除$C$的一个原子，获得其残留图，并通过求残留图的强连通分量获得$C$的所有子环，并对其重复次整个判断过程；
	\item $R^-(C)=R^-(L)$，此时意味着$C$和$L$都是某个环$L'$的子环，且它们有重叠。这种情况的处理实际和情况3是一样的：获取$C$的所有子环，并对其重复整个判断过程；
	\item 其他情况，即$C$和$L$或者$R^-(C)$和$R^-(L)$都没有直接的包含关系。此时的处理和情况3、4是一样的，不过，我们可以做一些优化：考虑到在$R^-(C)$中，实际上我们只需要关注的是其和$R^-(L)$的交集，所以，可以直接删掉$C$中的原子集$head(R^-(C)\backslash R^-(L))$得到残留图$G_C$，并获得$G_C$的强连通分量，最后对其重复整个判断过程。
\end{enumerate}

若没有找到任何$C$，使得$L$不是特征环，那么算法\ref{algo_ProperLoop}将返回$L$，表示$L$是特征环。

\RestyleAlgo{ruled}\LinesNumbered\input{algo/ProperLoop.tex}

算法\ref{algo_ProperLoop}采取自顶向下的策略，先大环开始，逐步深入到小环。
需要注意的是，该算法每次都至少删除子图中的一个原子。
所以，在最坏的情况下，算法将迭代$n^2$次，其中，$n$为环$L$中的原子数目，即算法\ref{algo_ProperLoop}的时间复杂度为$O(n^2)$。

\begin{corollary}\label{chap4_corollary_pl}
给定正规逻辑程序$P$，$L$是$P$的特征环，且满足$R^-(L) \ne \emptyset$。如果$L'$是$P$的一个环，且满足$L' \subset L$，$head(R^-(L)) \subseteq L'$，那么$L'$不是特征环。
\end{corollary}
\begin{proof}
因为$L$是特征环，且满足$L' \subset L$，由定义\ref{chap4_definition_nlp_properloop}，有$R^-(L') \nsubseteq R^-(L)$。另一方面，由$head(R^-(L)) \subseteq L'$，得$R^-(L) \subseteq R^-(L')$，所以，$R^-(L) \subset R^-(L')$。根据定义\ref{chap4_definition_nlp_properloop}，$L$使得$L'$不是特征环。\quad
\end{proof}

想要求得程序的所有特征环，一个直接的方法是，使用算法\ref{algo_ProperLoop}去对程序的每个环进行过滤。
显然，这样做的效率并不高，毕竟程序的环的数目是可能指数爆炸的。
利用推论\ref{chap4_corollary_pl}，我们可以直接忽略掉部分不可能是特征环的环，从而在一定的程度上提高算法的效率。

\RestyleAlgo{ruled}\LinesNumbered\input{algo/ProperLoops.tex}

给定正规逻辑程序$P$，算法\ref{algo_ProperLoops}将计算程序$P$在原子集合$S$下的所有特征环。
与之前的算法一样，算法\ref{algo_ProperLoops}也是采用自顶向下的方式考虑所有环。
记$P$的正依赖图$G_P$只含$S$中原子的子图为$G_P^S$。
首先，算法\ref{algo_ProperLoops}求得$G_P^S$的强连通分量$SCC$，然后，对$SCC$里面的每个强连通分量$C$使用算法\ref{algo_ProperLoop}判断其是否为特征环。
如果$C$是特征环，那么根据推论\ref{chap4_corollary_pl}，我们并不需要遍历所有子环，所以此时，每次删除$C$中的一个原子$a$，其中$a \in head(R^-(C))$，然后把残留图的强连通分量加入$SCC$中，并重复整个判断过程；如果$C$不是特征环，那么我们需要遍历其所有的子环，此时每次删除$C$中的一个原子，破坏其连通性，然后把残留图的强连通分量加入$SCC$中，并重复整个判断过程。

\section{析取逻辑程序的特征环}

本节，我们将把特征环的概念拓展到析取逻辑程序。
\subsection{特征环的定义}
\begin{definition}
给定析取逻辑程序$P$，$L$为$P$中的环。用$RLF(L,P)$表示以下的蕴含式：
\begin{equation}
\bigwedge_{p \in head(R^-(L)) \cap L} p \supset \bigvee_{p \in R^-(L)}(body(r) \wedge \bigwedge_{q \in head(r)\backslash L} \neg q)
\end{equation}

特别地，如果$R^-(L)=\emptyset$，则：
\begin{equation}
\bigwedge_{p \in L} p \supset \bot
\end{equation}

显然，$RLF(L,P)$是$LF(L,P)$的一个特殊形式。当使用这种形式的环公式时，我们可以在基本环的基础上，删除更多的环。
\end{definition}

\begin{corollary}\label{chap4_corollary_dlp_rlf}
给定析取逻辑程序$P$，$L_1$和$L_2$为$P$的环。
如果$R^-(L_1) \ne \emptyset$，$R^-(L_2)\\ \ne \emptyset$，$head(R^-(L_1)) \cap (L_1 \cup L_2) \subseteq head(R^-(L_2)) \cap L_2$，$R_{L_2}^-(L_1) \subseteq R^-(L_2)$，那么$RLF(L_1,P) \supset RLF(L_1,P)$。
\end{corollary}
\begin{proof}
待证明\quad
\end{proof}

基于推论\ref{chap4_corollary_dlp_rlf}，我们给出析取逻辑程序的特征环的定义。
\begin{definition}[析取逻辑程序的特征环]
给定析取逻辑程序$P$，$L$为$P$的环。我们称$L$为$P$的特征环，如果$L$满足：
\begin{enumerate}
	\item $L$是$P$的基本环；
	\item 不存在$P$中的其他基本环$L'$，使得$R^-(L') \ne \emptyset$，$head(R^-(L')) \cap (L' \cup L) \subseteq head(R^-(L)) \cap L$，$R_{L_2}^-(L') \subset R^-(L)$。
\end{enumerate}
\end{definition}