\chapter{求解器的实现}

在前面的章节中，我们提出了从一阶限定理论到一阶稳定理论的保持在所有结构上的投影等价关系的翻译，
以及从任意一阶稳定理论到在稳定模型语义下的全称一阶公式的保持在有穷结构上的投影等价关系的翻译，
根据公式间的可译性的传递性，我们可以将一个一阶限定理论保持在有穷结构上的投影等价关系翻译成在稳定模型语义下的一个全称一阶公式。
因此，本章将关注于通过计算在稳定模型语义下的一个全称一阶公式，实现一阶限定理论的计算。

本章首先讨论将全称一阶公式转化为与之强等价的扩充的析取逻辑程序，
以及将扩充的析取逻辑程序转换成回答集程序，
继而提出整个求解器的框架。基于前面章节所述的翻译，通过调用回答集求解器，本文实现了一个通用一阶限定理论的求解器{\sf cfo2lp}，
并给出其实现的具体步骤，及对每一步骤进行时间复杂度分析，
最后将它与基于回答集程序的命题限定理论求解器进行了比较。

\section{从全称一阶公式到回答集程序}

%稳定模型语义最开始被提出是
基于前面所述的翻译，我们可以得到在稳定模型语义下的一个全称一阶语句。
给定一个有穷论域，我们可以轻易地将一个全称一阶语句常例化，解释成一个命题公式。
举个例子来说，对于以下公式：
\begin{eqnarray}\label{emp_ufo2dlp}
\forall x \forall y [(P(x) \rightarrow Q(x)) \wedge S(y) \rightarrow T(x,y) ]
\end{eqnarray}
给定一类结构$\Sigma$，其论域为$\{1,2\}$，则公式(\ref{emp_ufo2dlp})与下列公式在$\Sigma$上强等价于下列公式的合取：
\begin{eqnarray}
(P(1) \rightarrow Q(1)) \wedge S(1) \rightarrow T(1,1)\label{emp_ufo2dlp1}\\
(P(1) \rightarrow Q(1)) \wedge S(2) \rightarrow T(1,2)\\
(P(2) \rightarrow Q(2)) \wedge S(1) \rightarrow T(2,1)\\
(P(2) \rightarrow Q(2)) \wedge S(2) \rightarrow T(2,2)
\end{eqnarray}

因此，在有穷结构上，对于每个在稳定模型语义下的全称一阶语句，都存在一个在稳定模型语义下的命题理论与之逻辑等价。

在2005年，Pedro Cabalar等人在\cite{Cabalar2005reducing}中提出，不同类型的命题理论可以翻译为与之强等价的EDLP逻辑程序。
在2007年，他们又在文献\cite{cabalar2007propositional}中，
证明了每一个稳定模型语义下的命题理论
都存在一个扩充的析取逻辑程序与之强等价(见第二章定理\ref{theorem_sm2lp})。
后来，Joohyung Lee和Ravi Palla在文献\cite{Lee2012}中总结了所有类型的命题理论，
完善了从命题理论到EDLP逻辑程序的保持强等价关系的翻译。

%在文献\cite{cabalar2005reducing}中，Cabalar等人给出了从任意全称稳定理论转化为析取逻辑程序的方法，主要包括两个
%转换规则集，为了不失一般性，在规则集中所有的蕴含式都先被转换成稳定语义下的否定范式。有如下将否定前缀向内移动，直到变成NNF的规则：
%\begin{align*}
%% \nonumber to remove numbering (before each equation)
%  \neg \top ~~&\Longleftrightarrow~~ \bot &(\mathrm{N1})&&
%  \neg \bot ~~&\Longleftrightarrow~~ \top &(\mathrm{N2}) \\
%  \neg\neg\neg\varphi ~~&\equiv^{s}~~ \neg\varphi &(\mathrm{N3})&&
%  \neg(\varphi~\wedge~\psi) ~~&\equiv^{s}~~ \neg\varphi~\vee~\neg\psi &(\mathrm{N4}) \\
%  \neg(\varphi~\vee~\psi) ~~&\equiv^{s}~~ \neg\varphi~\wedge~\neg\psi &(\mathrm{N5})&&
%  \neg(\varphi~\rightarrow~\psi) ~~&\equiv^{s}~~ \neg\neg\varphi~\wedge~\neg\psi &(\mathrm{N6})
%\end{align*}

在文献\cite{Lee2012}中，
每一个命题理论都被看作由若干个蕴含式合取而成的集合。
例如，若命题公式$\varphi$不包含蕴含联结符，则它可看作为$\top \rightarrow \varphi$。
该翻译实际上是将一个结构复杂的命题理论转化为
由结构单一和简单的公式的集合。

基于蕴含联结符的位置，这些翻译主要分为两类：
一类为蕴含式的前件相对复杂，我们称为左规则；另一类为蕴含式的后件相对复杂，称为右规则。
下面给出其中主要的翻译：

左规则：
\begin{align*}
% \nonumber to remove numbering (before each equation)
  \top~\wedge~\alpha~\rightarrow~\beta ~~&\equiv^{s}~~ {~\alpha~\rightarrow~\beta~} \tag{L1} \\
  \bot~\wedge~\alpha~\rightarrow~\beta ~~&\equiv^{s}~~ \emptyset \tag{L2} \\
  \neg\neg\varphi~\wedge~\alpha~\rightarrow~\beta ~~&\equiv^{s}~~ {~\alpha~\rightarrow~\neg\varphi~\vee~\beta~} \tag{L3} \\
  (\varphi~\vee~\psi)~\wedge~\alpha~\rightarrow~\beta ~~&\equiv^{s}~~ \left\{
        \begin{array}{rll}
            \varphi~\wedge~\alpha~&\rightarrow~\beta \\
            \psi~\wedge~\alpha~&\rightarrow~\beta
        \end{array}
    \right\} \tag{L4} \\
  (\varphi~\rightarrow~\psi)~\wedge~\alpha~\rightarrow~\beta ~~&\equiv^{s}~~ \left\{
        \begin{array}{rll}
            \neg\varphi~\wedge~\alpha~&\rightarrow~\beta \\
            \psi~\wedge~\alpha~&\rightarrow~\beta \\
            \alpha~&\rightarrow~\varphi~\vee~\neg\psi~\vee~\beta
        \end{array}
    \right\} \tag{L5}
\end{align*}

右规则：
\begin{align*}
% \nonumber to remove numbering (before each equation)
  \alpha~\rightarrow~\bot~\vee~\beta ~~&\equiv^{s}~~ {\alpha~\rightarrow~\beta} \tag{R1} \\
  \alpha~\rightarrow~\top~\vee~\beta ~~&\equiv^{s}~~ \emptyset \tag{R2} \\
  \alpha~\rightarrow~\neg\neg\varphi~\vee~\beta ~~&\equiv^{s}~~ {\neg\varphi~\wedge~\alpha~\rightarrow~\beta} \tag{R3} \\
  \alpha~\rightarrow~(\varphi~\wedge~\psi)~\vee~\beta ~~&\equiv^{s}~~ \left\{
        \begin{array}{rll}
            \alpha~&\rightarrow~\varphi~\vee~\beta \\
            \alpha~&\rightarrow~\psi~\vee~\beta
        \end{array}
    \right\} \tag{R4} \\
  \alpha~\rightarrow~(\varphi~\rightarrow~\psi)~\vee~\beta ~~&\equiv^{s}~~ \left\{
        \begin{array}{rll}
            \varphi~\wedge~\alpha~&\rightarrow~\psi~\vee~\beta \\
            \neg\psi~\wedge~\alpha~&\rightarrow~\neg\varphi~\vee~\beta
        \end{array}
    \right\} \tag{R5}
\end{align*}
其中，$\varphi,\psi,\alpha$和$\beta$
均为命题公式。

通过上述左规则和右规则，我们可以将一个命题理论在有限步内转化为由形如公式(\ref{ruleDLP})的规则组成的集合。
例如，对于上述的公式(\ref{emp_ufo2dlp1})，根据左规则(L5)，我们可以用下面的规则的合取表示它：
\begin{eqnarray}
 T(1,1)\leftarrow \neg P(1)  \wedge S(1) \\
 T(1,1) \leftarrow Q(1) \wedge S(1)\\
 T(1,1) \vee P(1) \vee \neg Q(1) \leftarrow S(1) \label{emp_ufo2dlp2}
\end{eqnarray}

章衡在他的博士论文\cite{Heng2011thesis}中
提出了一个将扩充的析取逻辑程序转化为析取逻辑程序的翻译$Tr_{\neg\neg}$(见第二章命题\ref{prop_edlp2dlp})。
例如，将公式(\ref{emp_ufo2dlp2})应用于翻译$Tr_{\neg\neg}$，我们可得：
\begin{eqnarray}
 T(1,1) \vee P(1) \leftarrow S(1) \wedge \neg Q'(1) \\
 Q'(1) \leftarrow \neg Q(1)
\end{eqnarray}

注意到以上的翻译都是基于稳定模型语义的，因此，这里析取逻辑程序实际上就是回答集程序。

综上所述，
我们有下面的定理：
\begin{theorem}\label{theorem_sm2asp}
每一个$\Pi^0_1$-语句都在有穷结构上强等价于一个回答集程序，
并且存在一个翻译算法，将任意一个$\Pi^0_1$-语句在有穷结构上在有穷时间内，转换成与之强等价的回答集程序。
\end{theorem}
根据上面的定理，我们可以将任意一个在稳定模型语义下的全称一阶语句
翻译为与之在有穷结构上逻辑等价的回答集程序。

\section{通用一阶限定理论求解器~cfo2lp~}

\subsection{~cfo2lp~的计算框架}
\begin{figure}[h!]
  \center
  \includegraphics[width=400pt]{img/framework.jpg}\\
  %\includegraphics[width=10cm]{img/solver.jpg}\\
  \caption{一阶限定理论求解器~cfo2lp~的计算框架} \label{fig:framework}
\end{figure}

因为
一阶语句间的逻辑等价性在一阶限定理论中仍然得到保持(见命题\ref{equcirc}和命题\ref{equpri})，
以及每个全称一阶理论都与一个命题理论在有穷关系上强等价，
因此，
基于前面章节所述的保持在有穷结构上的投影等价关系的翻译：
\begin{itemize}
  \item 从一阶限定理论到一阶稳定理论：
      \begin{itemize}
        \item 从一阶并行限定理论到一阶稳定理论的翻译$Tr_v$，
        \item 从若干个一阶并行限定理论到一阶稳定理论的翻译$Tr^s_v$，
        \item 从一阶带优先级的限定理论到一阶稳定理论的翻译$Tr^p_v$，
        \item 从一阶带优先级的限定理论到一阶稳定理论的翻译$Tr_P$；
      \end{itemize}
  \item 一阶限定理论中的存在量词消去：
      \begin{itemize}
        \item 一阶并行限定理论中的存在量词消去的优化翻译$\Gamma_{\exists}$，
        \item 一阶带优先级的限定理论中的存在量词消去的优化翻译$\Gamma^p_{\exists}$；
      \end{itemize}
  \item 稳定模型语义下的存在量词消去翻译$Tr_{QE}$；
  \item 从命题理论到EDLP逻辑程序的保持强等价关系的翻译；
  \item 从EDLP逻辑程序到回答集程序的翻译$Tr_{\neg\neg}$，
\end{itemize}
我们可以构造一个将任意一阶限定理论转化为与之在有穷结构上投影等价的回答集程序的翻译，
通过求解回答集程序的模型，从而实现计算一阶限定理论的所有模型的求解器，cfo2lp。

直观地，图\ref{fig:framework}反映了一阶限定理论求解器~cfo2lp~的计算框架。
其中，$\textrm{CIRC}$表示限定理论，$\textrm{SM}$表示稳定模型语义，$\textrm{ASP}$表示回答集程序，
$\textrm{FO}$表示一阶理论，$\textrm{UFO}$表示全称一阶语句。

\subsection{具体实现步骤}

通过对从一阶限定理论到一阶稳定理论的翻译和一阶限定理论中的存在量词消去的优化翻译的分析，我们发现它们均对合取符合“分配律”，
换句话说，这些翻译可以独立应用于单个合取式而不影响等价性。
下面的定理说明该性质：
\begin{theorem}
设$\varphi$和$\psi$为任意两个一阶语句，$\sigma_m$和$\sigma_v$表示两个互不相交的谓词常元集，$Tr$表示翻译，且$Tr \in \{Tr_v,Tr^s_v.Tr^p_v,Tr_p,\Gamma_{\exists},\Gamma^p_{\exists}\}$，
则有$\textrm{SM}[Tr(\varphi) \wedge Tr(\psi);\sigma_m,\tau]$与$\textrm{CIRC}[\varphi \wedge \psi;\sigma_m;\sigma_v]$在有穷结构上投影等价，其中$\tau$表示有翻译$Tr$引入的辅助谓词的集合。
\end{theorem}
根据上述定理，
最终生成的一阶稳定理论的规模取决于原一阶理论中合取项的最大长度。
因此，
我们可以将任意一个一阶理论尽可能的拆分成若干个规模较小的合取项，
从而降低最终生成的回答集程序的规模。

从限定理论与稳定模型语义的定义看，限定理论中的固定谓词常元与稳定模型语义中的外延谓词常元类似，
均不引入相应的谓词变元，
就连处理方法也是相同的：
引入其选择规则(见第二章定理\ref{theorem_c2sm}和\ref{theorem_smextensional})。
因此，对于那些在最终生成的回答集程序中，出现在规则体部的的固定谓词常元$P$，
我们都要加入规则$choice(P)$，即$\forall \bar{x}(P(\bar{x})\vee \neg P(\bar{x}))$。

此外，在限定理论中，还存在一类与稳定模型语义截然不同的谓词常元――可变谓词常元。
在前面章节的翻译中，我们对每个可变谓词常元都引入了一个相应的具有相同元数的辅助谓词常元，
使得在翻译后的一阶稳定理论中，这些可变谓词常元不属于内涵谓词常元，
也就是说，限定理论中的可变谓词常元在翻译后实际上变成了稳定模型语义中的外延谓词常元。
因此，对于可变谓词常元$Q$，若它出现在最终的回答集程序中的某条规则的体部，那么我们要加入规则$\forall \bar{x}(Q(\bar{x})\vee \neg Q(\bar{x}))$。

综上所述，
我们总结一阶限定理论求解器~cfo2lp~的步骤为下列六步：
\begin{itemize}
  \item 将输入的一阶理论转化成若干个具有前缀范式形式和否定范式形式的公式的合取；
  \item 按照不同的限定策略以及第一步得到的合取式的结构选择从一阶限定理论到一阶稳定理论的翻译：
    \begin{itemize}
      \item 若是一阶并行限定理论，且是$\Pi^0_1$-语句，则选择翻译$Tr_v$；
      \item 若是一阶带优先级的限定理论，且是$\Pi^0_1$-语句，则选择翻译$Tr_p$；
      \item 若是一阶并行限定理论，且不是$\Pi^0_1$-语句，则选择翻译$\Gamma_{\exists}$；
      \item 若是一阶带优先级的限定理论，且不是$\Pi^0_1$-语句，则选择翻译$\Gamma^p_{\exists}$；
    \end{itemize}
  \item 将翻译后的公式转化成前缀范式，若仍存在具有存在量词的语句，则重复调用翻译$Tr_{QE}$直至得到一个全称一阶语句；
  \item 为每一个可变谓词常元和固定常元$Q$，加入公式$choice(Q)$；
  \item 将所有全称一阶语句转化为回答集程序；
  \item 给定一个论域，调用回答集求解器，得到最终的模型。
\end{itemize}

%\subsection{时间复杂度分析}
下面我们对上面的每个具体步骤进行时间复杂度上的分析。
假设输入的一阶理论的规模为$n$，其最长的嵌套的量词块为$k$，那么：
\begin{itemize}
  \item 按照逻辑等价关系和强等价关系，将否定词$\neg$不断向原子公式移动，将量词不断提到前面，因此时间复杂度为$O(n)$；
  \item 基于语法层面的翻译，时间复杂度为为$O(n)$；
  \item 跟量词的嵌套情况有关，时间复杂度为$O(2^kn)$；
  \item 可变谓词常元和固定谓词常元的个数有限，远小于理论的规模，则时间复杂度为$O(1)$；
  \item 将全称一阶语句转化成回答集程序会不断调用类似于“分配律”的翻译，其耗费时间取决于最长量词嵌套的合取项，因为第一步中已将语句转化成否定范式，所以最后的公式的结构会相对简单，
  此处造成的往往是规模上多项式的膨胀，因此这个过程的时间复杂度可以视作$O(n^m)$，其中$m$为一正实数；
  \item 回答集程序的求解问题属于$\Sigma_2^p$问题，
\end{itemize}
综上所述，一阶限定理论求解器cfo2lp能够在多项式时间内将一阶理论翻译成回答集程序，时间复杂度为$O(n^m)$；而它的求解时间取决于调用的回答集求解器的求解时间。

\subsection{与命题限定理论求解器的比较}

对于一种知识表示语言，它对问题的表达的自然性和计算效率如同鱼与熊掌，两者往往不可兼得。
例如，高阶逻辑能够十分自然地表示大部分数学问题，但是在计算机上实现其有效推理却十分困难，
实际应用仍然有待发展；
而逻辑程序在求解问题上有较高的效率，
但却是建立在牺牲一定的表达自然性的基础上，
存在量词的不允许限制了它表示问题的灵活性和简洁性。
本文致力于在两者之间取得一个平衡，
在不牺牲一阶限定理论的表达能力的情况下，
尽可能的提高其求解效率。
因此，本文实现了一个通用一阶限定理论的求解器，适用于限定理论语义下的任意一阶语句。

与一阶限定理论求解器相比，不少国外学者更关注计算效率，发展了一些命题限定理论求解器。
之所以称之为命题限定理论，是因为它的输入必须是全称一阶语句。不允许存在量词的存在，往往牺牲了对问题的表达自然性和灵活性。

\begin{figure}[htb]
  \center
  \includegraphics[width=300pt]{img/proposition_framework.jpg}\\
  %\includegraphics[width=10cm]{img/solver.jpg}\\
  \caption{命题限定理论求解器的计算框架} \label{fig:proposition_framework}
\end{figure}

图\ref{fig:proposition_framework}反映了一般基于回答集程序的命题限定理论求解器的计算框架。
与本文的一阶限定理论求解器的计算框架(图\ref{fig:framework})比较，
我们可以发现，对于本文的一阶限定理论求解器cfo2lp，
直到最后调用回答集求解器的时候才需要一个论域，
而
命题限定理论求解器往往需要固定一个论域，
然后再将问题编码成回答集程序。
当面对同一类问题时，两者都可以用限定理论语义下的一阶语句表示它，
只要得到该类问题的一个实例，就可以通过回答集求解器求得其解决方案。
但是，
当我们要求解同一类问题的另一个实例，
对于命题限定理论求解器，我们往往需要重新编码一次，
而对于一阶限定理论求解器，我们只需要简单的改变输入的论域。

此外，对于那些需要用到存在量词来表示的问题，
基于回答集程序的命题限定理论求解器就需要
将输入公式转化为等价的合取范式，
而这个过程往往会生成许多的子句，
造成规模上的指数膨胀，
最终使得回答集程序难以计算。
然而，对于一阶限定理论求解器cfo2lp，
存在量词的消去并不是基于合取范式的转化，
不会造成类似的指数膨胀。

\section{本章小结}

本章总结了前面章节所提出的翻译，结合了已有的理论结果，
提出了计算一阶限定理论的实现框架，
详细给出了每一个具体实现步骤，
并对每一步的时间复杂度都进行了分析，
实现了一个一阶限定理论求解器cfo2lp。
cfo2lp可以在多项式时间内将
一阶限定理论翻译为回答集程序，
通过调用回答集求解器，
有效计算出一个一阶理论的所有极小模型。

此外，本章还从知识表示语言的两个主要方面，对问题的表达自燃性和计算效率，比较了一阶限定理论求解器与命题限定理论求解器。
相比于基于回答集程序的命题限定理论求解器，
本文的一阶限定理论求解器cfo2lp，允许使用存在量词，因此可以更自然、更直观、更灵活地表示不同的问题；
对于同一类问题，cfo2lp不会因为问题实例的改变而需要重新编码；
cfo2lp不会对公式的输入形式进行限制，也不会因为将输入的一阶限定理论转化为某种范式
而造成理论规模上的指数膨胀，使得程序难以计算。
总的来说，一阶限定理论求解器cfo2lp，比基于回答集程序的命题限定理论求解器，具有更强的表达能力，对问题具有更好的表达自然性。

