\def\qed{\hfill \vrule height6pt width 6pt depth 0pt}
\newcommand{\g}{\mathbf{g}}
\newcommand{\hh}{\mathbf{h}}
\chapter{海明空间的$k$近邻搜索}

为了满足大规模图像检索的需求，一张图片经过特征提取之后，通常会对其进行哈希，
处理成固定长度的二进制码（如：64位、128位等）。由于采用固定长度（通常都会
比较短）的二进制码来表示一张图片，一张图片所占用的内存大小会比较小，使得后
续大规模数据的$k$近邻搜索可以在内存中完成。此外，对于两个二进制码的距离度量
通常会采用海明距离进行衡量，如今的x86计算机体系架构的CPU 可以利用POPCNT硬件指
令来计算两个数间的海明距离,使得$k$近邻搜索时计算两张图片间的海明距离可以很快
速地完成。

本章将会讲述图像检索中海明空间的$k$近邻搜索，首先会分析线性搜索算法，然后会详
细描述MIH算法的原理以及实现技巧，最后本章会提出MIH 算法在相似衣服的图像检索应
用中的优化，我们提出了一种基于贪心思想的算法对用来表示衣服图片的二进制码中的
0-1值进行重排列，通过这个优化可以提高MIH算法的搜索效率。

\section{线性搜索算法}

\begin{definition}
给定一个二进制码数据集，$\mathcal{H} = \{\mathbf{h}_i\}_{i = 1}^n$，在数
据集$\mathcal{H}$中找到与给定查询的二进制码的海明距离最近的$k$个二进制码，
这个过程是海明空间的$k$近邻搜索。
\end{definition}

给定长度为$m$的二进制码$\mathbf{u}$，任意一个长度为$m$的二进制码$\mathbf{v}$
与其的海明距离不会超过$m$，即
\begin{equation}
\|\mathbf{u} - \mathbf{v}\|_H \le m
\end{equation}
其中$\mathbf{u}, \mathbf{v} \in \{0, 1\}^q$，$\|\cdot\|_H$表示海明范数。由于数据
集中的向量与查询向量的海明距离存在上界，因此，对海明距离进行排序可以采用时间
复杂度为$O(n)$的计算排序进行。

计数排序的算法过程需要对数据遍历2趟，如算法\ref{algo_CountingSort}所示。然而，对
于海明距离存在上界的$k$近邻搜索，我们只需要对数据遍历一趟，即分别记录$0 \sim m$
每个海明距离所对应的数据，然后从小到大枚举海明距离，获取相关的数据，如算法
\ref{algo_LinearSearch}所示。

\RestyleAlgo{ruled}\LinesNumbered\input{algo/CountingSort.tex}

\section{多重索引哈希算法（Multi-Index Hashing）}

\begin{definition}
给定一个二进制码数据集，$\mathcal{H} = \{\mathbf{h}_i\}_{i = 1}^n$，在数
据集$\mathcal{H}$中找到与给定查询的二进制码的海明距离不超过$r$的二进制码，即它们
之间只有不超过$r$位的值不同，这个过程是海明空间的$r$近邻搜索。
\end{definition}

M.Norouzi, A.Punjani等人提出了一种构建多重索引的哈希算法可以在海明空间下进行
$r$近邻的精确搜索，该算法简称“MIH算法”\cite{norouzi2014fast}。

对于数据集$\mathcal{H}$中的每一个向量$\hh \in \{0, 1\}^q$，我们可以对其划分为$m$
个不相交的子串，$\hh^{(1)},..,\hh^{(m)}$，每一个子串长度为$q/m$位，不失一般性
地，我们假设$q$可以整除$m$\footnote{如果$q$不能整除$m$，则每一个子串长度为
$\lfloor \frac{q}{m} \rfloor$或者$\lceil \frac{q}{m} \rceil$。}，每个子串由连
续的若干位组成。如果查询向量$\g$与向量$\hh$的海明距离不超过$r$位，那么
$m$对对应的子串中至少有一对子串间的海明距离不超过$\lfloor r / m \rfloor$，即
命题\ref{pro_1}。

\begin{proposition}
\label{pro_1}
如果$\|\hh - \g\|_H \le r$，那么
\begin{equation}
\exists 1 \le z \le m \quad\quad \mbox{s.t.}\quad \|\hh^{(z)} - \g^{(z)}\|_H \le r'
\end{equation}
其中$r' = \lfloor r / m \rfloor$。
\end{proposition}

\begin{proof}
通过鸽巢原理直接得出命题，此外，也可以通过反证法证得。假设每个相对应的子串间的
海明距离都大于$\lfloor r / m \rfloor$，即每个子串间的海明距离至少为$\lfloor r / m \rfloor + 1 $。
令$r' = \lfloor r / m \rfloor$，那么$r = mr' + a$，$0 \le a < m$。而此时向量
$\hh$和$\g$之间的海明距离至少为$mr' + m$，即向量$\hh$和$\g$之间的海明距离大于$r$，
这与前提矛盾，由此得证。
\end{proof}

\RestyleAlgo{ruled}\LinesNumbered\input{algo/LinearSearch.tex}

MIH算法构建多重索引的过程是，首先初始化$m$个哈希表$B_1, ..., B_m$，假设
$B_i$所对应的子串区域长度为$b_i$位，那么$B_i$表中有$2^{b_i}$个哈希桶，即$b_i$位所能表
示的所有二进制数，然后我们对数据集$\mathcal{H}$中的每一个向量$\hh_i \in \{0, 1\}^q$
划分为$m$个子串，每个子串由连续的$\lfloor q / m \rfloor$ 位或者$\lceil q / m \rceil$位组成，
最后分别以这些子串所表示的二进制数作为哈希桶的键，向量的id作为值，依序将这$m$对键值对插
入到对应的哈希表中的桶中。算法伪代码如算法\ref{algo_MIHPreprocess}所示。

\RestyleAlgo{ruled}\LinesNumbered\input{algo/MIHPreprocess.tex}

给定一个查询向量$\g \in \{0, 1\}^q$，在数据集$\mathcal{H}$中查找向量$\g$的$r$近邻向量
的过程是，首先我们对向量$\g$划分$m$个子串，划分策略和构建多重索引时一致。根据命题\ref{pro_1}
的描述，我们可以分别对这$m$个子串枚举与子串的海明距离不超过$\lfloor r / m \rfloor$
的键，然后到对应的哈希表中遍历该键所对应的桶中的向量，对每一个桶中的向量计算其与查询
向量$\g$的海明距离，最后将所有距离超过$r$的向量去除，便得到了向量$\g$的所有$r$近邻向量。
作者们通过进一步的研究，可以发现对于查询向量$\g$，枚举哈希桶键时不需要枚举到海明距离为
$\lfloor r / m \rfloor$的键，只需要枚举到$\lfloor r / m \rfloor - 1$即可，在这里，本文不再赘述
这部分的证明，算法的伪代码如算法\ref{algo_MIHQuery}所示。

\RestyleAlgo{ruled}\LinesNumbered\input{algo/MIHQuery.tex}

\section{MIH算法的实现技巧}

本节会讲述MIH算法在实现时的一些小技巧，通过使用这些小技巧可以提高MIH算法的效率。

\subsection{相同海明距离的哈希键的枚举}

MIH算法根据二进制码的子串值构建索引，一般来说二进制码所划分的子串长度不会太长（在64位
以内），我们可以使用一个整型储存哈希键的值。假设子串长度为$b$，计算一个与该子串的海明距离
为$r$的哈希键可以通过将子串与一个长度同样为$b$，其中只有$r$位的值为1的二进制码进行异或操
作得出，因此只需要枚举这$r$个1在$b$位长度的二进制码中的排列，进而通过与子串进行异或操作
便可以枚举出所有具有相同海明距离的哈希键。

枚举$r$个1在$b$位长度的二进制码中的排列可以通过简单的几步操作完成，见算法
\ref{algo_Permutation}\footnote{该算法参考http://www.geeksforgeeks.org/archives/10375/}。

\RestyleAlgo{ruled}\LinesNumbered\input{algo/Permutation.tex}

\subsection{算法提前退出的条件}

MIH算法是$r$近邻的精确搜索算法，其应用到$k$近邻搜索时，需要有一个前提假设，即与查询向量
$\g$海明距离最接近的$k$个向量的最大距离不超过$r$。通过设置参数$r$，MIH算法可以完成$k$近邻搜索。
在枚举$r$个1在$b$位长度的二进制码中的排列的时间复杂度为$O(C_b^r)$，其中$C$为组合数。一般来
说，在枚举下一个海明距离（不超过$b / 2$）的哈希键所耗费的时间要比枚举当前海明距离的要多得多，
因此，如果能够在较短的海明距离里获取到$k$个近邻结果的话，那么算法的效率便会比较高。在实现
MIH算法的时候，我们每一趟都对$m$个子串枚举相同长度的海明距离的哈希键，枚举完后再进行下一
个海明距离的哈希键的枚举。由于海明距离存在上界，在枚举的同时可以记录每一个海明距离所对应的
向量个数，枚举完一个子串的哈希键后可以进行停止条件的判断从而有机会在比较短的海明距离里结束
算法，这个停止条件基于命题\ref{pro_stop}。

\begin{proposition}\label{pro_stop}
假设此时对查询向量$\g$的第$k + 1$个子串进行海明距离为$s$的搜索，那么当枚举完所有与该子串
海明距离为$s$的哈希键后，数据集中所有与查询向量$\g$的海明距离为$s \times m + k$的向量都已
经被查询过了。
\end{proposition}

\begin{proof}
对于到目前为止数据集中还没有被查询过的向量，这些向量与查询向量$\g$所对应的$m$个子串中，前
$k + 1$个子串间的海明距离至少是$s + 1$，后面$m - (k + 1)$的子串间的海明距离至少是$s$，因此
这些向量与查询向量$\g$的海明距离至少是$(s + 1) \times (k + 1) + (m - (k + 1)) \times s = ms + k + 1$，
因此，所有不超过$s \times m + k$的向量都已经被查询过了，如果这个海明距离的向量没有被找到，
之后也不会再被找到。
\end{proof}

综上，我们可以得到一个停止条件，在对查询向量$\g$的第$k$个子串进行海明距离为$s$的搜索后，可以
累加海明距离在$s \times m + k - 1$的向量数，因为这个海明距离是从0开始递增的，所以目前累加得到
的总向量数如果超过$k$，则可以提前退出算法（类似算法\ref{algo_LinearSearch}的第$9 \sim 11$ 行的
条件判断)。

\section{MIH算法在应用中的优化}

我们将MIH算法应用在相似衣服的图像检索中，在实际应用中我们发现MIH算法默认的哈希策略（二进制连续
的若干位作为一个哈希键）存在数据集中的向量不能相对均匀地分配在哈希表中的每个哈希桶中，这会影响
MIH算法的效率。MIH算法能够在次线性的时间复杂度内进行$r$近邻的精确搜索的原因在于MIH算法不需要遍
历一遍整个数据集，通过构建多重索引可以在整个数据集的子集中遍历向量从而到达目的，因此，子集的大
小决定了MIH算法的运行效率，而对于数据集中的向量不能够相对均匀地分配在哈希表中的每个哈希桶中，这
会有让查询子集增大的风险，极端情况下，一个哈希桶中存在数据集中的大部分向量，那么当对查询向量$\g$
的子串进行哈希键的枚举时，如果枚举到了这个哈希桶，那么算法将会遍历数据集中的大部分向量，因此会耗
费比较多的时间。

为了解决这个实际问题，我们提出了一种基于贪心思想的算法，对图像的二进制表示进行重排，即对二进制码
中的0-1值的顺序进行重新排列，这会在一定程度上让数据集的向量相对均匀地分布在哈希表中的每个哈希桶中。

我们将数据集$\mathcal{H} = \{\hh_i\}_{i = 1}^n$，$\hh_i \in \{0, 1\}^q$看成是一个维度为$n \times q$的
0-1矩阵。对这个矩阵的每一列的0-1值，我们可以计算其方差。对于方差比较大的列，以这一列上的值作为两
类向量的划分标准（$0$为一类，$1$为另一类）可以比较均匀地区分出这两类的向量，而反差比较小的列，以该列
上的值作为划分标准则比较难地均匀区分两类。于是，当我们结合若干列作为一个划分标准时，希望其中方差
大和方差小的列的比例比较恰当，以这样的标准划分数据可以做到相对的均匀。因此，问题则转变为对这$q$
位划分为$m$份，每一份是$\lfloor q / m \rfloor$或者$\lceil q / m \rceil$位，并且每一份的方差和比较
接近，用公式化表达如公式\ref{knapsack_problem}所示。

\begin{equation}\label{knapsack_problem}
\begin{aligned}
\min \frac{1}{m(m - 1)} \sum_{i = 1}^m\sum_{j = i + 1}^m \left|
\operatorname{SV}(\mathbf{S}_i) - \operatorname{SV}(\mathbf{S}_j) \right| \\
s.t. \quad |\mathbf{S}_i| = \lfloor \frac{b}{m} \rfloor or \lceil \frac{b}{m} \rceil ,
\quad \sum|\mathbf{S}_i| = b
\end{aligned}
\end{equation}
其中函数$\operatorname{SV}$是对集合$\mathbf{S}_i$中的元素的方差进行求和操作。

这个问题是一个背包问题，属于NP难的问题，因此，我们提出了一个基于贪心思想的算法，在一定程度上尝试
解决这个问题。假设矩阵某一列上有$x$个$0$，则该列上有$n - x$个$1$，那么该列的方差为

\begin{equation}\label{eq_var}
\begin{aligned}
var & =  \frac{1}{n} \left( x(0 - \frac{n - x}{n})^2 + (n - x)(1 - \frac{n - x}{n})^2 \right)  \\
    & =  \frac{1}{n} \left( \frac{x(n - x)^2}{n^2} + \frac{(n - x)x^2}{n^2} \right) \\
    & =  \frac{1}{n} \left( \frac{x(n - x)(n -x + x)}{n^2} \right) \\
    & =  \frac{x(n - x)}{n^2}
\end{aligned}
\end{equation}

由公式\ref{eq_var}可得某一列上的方差是一条以$n / 2$为对称轴开口向下的抛物线，当$0$和$1$的个数相等时，
方差最大。为了去除浮点数运算，我们定义了公式\ref{eq_ratio}，其中$\mbox{\#$0$s}$和$\mbox{\#$1$s}$分别
表示该列上$0$的个数和$1$的个数。公式\ref{eq_ratio}是一条以$n / 2$为对称轴开口向下的折线，同样地，当
$0$和$1$的个数相等时，$ratio$值将会最大。我们以公式\ref{eq_ratio}代替方差作为我们评价该列作为划分标准
时均匀区分两类向量的能力。

\begin{equation}\label{eq_ratio}
ratio = \min(\mbox{\#$0$s}, \mbox{\#$1$s})
\end{equation}

于是，我们对用来表示数据集$\mathcal{H}$的矩阵的每一列按公式\ref{eq_ratio}计算其$ratio$值，然后对这些
$ratio$值按从大到小的顺序排序，接着每一次依序处理$m$列（最后一轮可能不够$m$列），以贪心的策略将这些列
加入到已有的集合中，尽量使得当前集合间的总值相差不大（不需要到达最优），优化算法的伪代码见算法\ref{algo_Rearrange}。
值得注意的是，算法\ref{algo_Rearrange}一开始对$f_1, ..., f_q$按从大到小排序而不是从小到大排序的原因是
考虑到总位数$q$不一定能够整除$m$，因此，在最后一轮中有些集合会增加元素，有些集合则保持不变，此时所处理
的是较小的$ratio$值可以保证集合所增加的量相对比较小。

\RestyleAlgo{ruled}\LinesNumbered\input{algo/Rearrange.tex}

\section{本章小结}

本章讲述了海明空间中的$k$近邻搜索，首先讲述了线性搜索算法，然后讲述了多重索引哈希算法（MIH算法）的原理
以及在实现中的一些技巧，接着讲述当我们将MIH算法应用到我们的相似衣服图像检索的应用中所遇到的问题，最后
讲述了针对所碰到的问题我们所提出来的优化算法，提高了MIH算法在实际应用中的效率。

在下一章中，我们会讲述我们实现的相似衣服图像检索系统，并且将MIH算法应用到后台系统中的相似图片搜索模块
中。
