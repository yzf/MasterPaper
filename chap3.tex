\chapter{全新的基本环(Elementary Loops)}
本文在对Gebser等人\cite{gebser2005loops}提出的基本环进行深入研究后，提出了基本环的另一种更为直观的定义。
基于这种全新的定义，我们提出一个新的识别算法。
该算法的时间复杂性和Gebser等人\cite{gebser2005loops}提出的一样，然而，本文的算法使用的是自顶向下的策略，而Gebser等人\cite{gebser2005loops}的则是自底向上。
算法的核心思想来源于环的外部支持和环公式。
本章先针对正规逻辑程序讨论基本环的概念，然后，我们把基本环拓展到析取逻辑程序。

\section{正规逻辑程序的基本环}
本节，我们将针对正规逻辑程序，提出基本环的另一种定义，并基于这种定义，给出对应的识别算法。

\subsection{基本环的定义}
在定义基本环之前，我们先给出与合取环公式相关的推论。
\begin{corollary}\label{chap3_corollary_nlp_el_clf}
给定正规逻辑程序$P$，$L_1$和$L_2$为$P$的环。如果$L_1 \subseteq L_2$且$R^-(L_1) \subseteq R^-(L_2)$，那么有$CLF(L_1,P) \supset CLF(L_2,P)$。
\end{corollary}
\begin{proof}
记$A=\bigwedge_{p \in L_1}p$，$B=\bigwedge_{p \in L_2}p$，$C=\bigvee_{r \in R^-(L_1)}body(r)$，\\
$D=\bigvee_{r \in R^-(L_2)}body(r)$，则
\begin{eqnarray*}
&& CLF(L_1,P) \supset CLF(L_2,P)\\
&& \Leftrightarrow (A \rightarrow C) \rightarrow (B \rightarrow D)\\
&& \Leftrightarrow (\neg A \vee C) \rightarrow (\neg B \vee D)\\
&& \Leftrightarrow (A \wedge \neg C) \vee (\neg B \vee D)\\
&& \Leftrightarrow (A \vee \neg B \vee D) \wedge (\neg C \vee \neg B \vee D)
\end{eqnarray*}

另一方面，对于$L_1 \subseteq L_2$，有：$\bigwedge_{p \in L_1}p \leftarrow \bigwedge_{p \in L_2}p$，即$B \rightarrow A$为真。
对于$R^-(L_1) \subseteq R^-(L_2)$，有：$\bigvee_{r \in R^-(L_1)}body(r) \rightarrow \bigvee_{r \in R^-(L_2)}body(r)$，即$C \rightarrow D$为真。所以有：
\begin{eqnarray*}
&& true \wedge true\\
&& \Leftrightarrow (B \rightarrow A) \wedge (C \rightarrow D)\\
&& \Leftrightarrow (\neg B \vee A) \wedge (\neg C \vee D)\\
&& \Rightarrow (\neg B \vee A \vee D) \wedge (\neg C \vee \neg B \vee D)
\end{eqnarray*}

由于对于$p \rightarrow q$为真，若$p$为真，则$q$为真，所以得出$CLF(L_1,P) \supset CLF(L_2,P)$\\
为真。\quad
\end{proof}

由推论\ref{chap3_corollary_nlp_el_clf}，我们可以知道，对于符合$L_1 \subseteq L_2$且$R^-(L_1) \subseteq R^-(L_2)$的两个环$L_1$和$L_2$，
因为$L_1$的环公式已经可以蕴含$L_2$的环公式了，所以$L_2$的环公式就没有存在的必要。

\begin{definition}[未被抑制的]\label{chap3_definition_unsubdued}
	给定程序$P$和环$L$，如果不存在$P$中的其他环$L'$，满足$L' \subset L$和$R^-(L') \subseteq R^-(L)$，那么我们称$L$是未被抑制的(unsubdued)。
\end{definition}
\begin{theorem}\label{chap3_theorem_eq3}
	给定程序$P$和原子集合$S$，如果$S$满足$P$，那么以下结论与定理\ref{chap2_theorem_eq1}和定理\ref{chap2_theorem_eq2}的结论都是等价的：
	\begin{enumerate}
		\item 对于$P$中的所有未被抑制的环$L$，$S$满足$CLF(L,P)$。
	\end{enumerate}
\end{theorem}

直观地，定义\ref{chap2_definition_outbound}的外向概念想要表达的意思为：
原子集合$Y$在$X$中是外向的，当且仅当存在$r \in P$，使得$r \in R^-(Y)$且$r \in R^-(X)$。所以，我们有以下推论。

\begin{corollary}\label{chap3_corollary_outbound}
	给定逻辑程序$P$和环$L$， $L$的任意非空真子集$L'$是外向的，当且仅当$R^-(L') \nsubseteq R^-(L)$。
\end{corollary}

根据定义\ref{chap3_definition_unsubdued}和推论\ref{chap3_corollary_outbound}，我们可以得出基本环的另一种定义：

\begin{definition}[正规逻辑程序的基本环]\label{chap3_definition_elementaryloops}
	给定正规逻辑程序$P$和环$L$，若$L$是未被抑制的，则$L$是$P$的基本环。
\end{definition}

\subsection{基本环的识别}

根据定义\ref{chap3_definition_elementaryloops}，我们基于正依赖图，给出了识别基本环的算法\ref{algo_ElementaryLoop}。
该算法从环$L$出发，考虑其子环的性质。
为了得到$L$的子环，我们的方法是先通过剔除$L$中的一个原子破坏$L$的连通性，得到其子图，
然后通过求子图的强连通分量得到子环的集合，对于每个子环$C$：

\RestyleAlgo{ruled}\LinesNumbered\input{algo/ElementaryLoop.tex}

\begin{enumerate}
	\item 如果$R^-(C) \subseteq R^-(L)$，那么子环$C$是被抑制的，这就使得环$L$不符合基本环的定义；
	\item 如果$R^-(C) \nsubseteq R^-(L)$，那么对于任意的$r \in R^-(C) \backslash R^-(L)$，有$r \in R^-(L)$，若$head(r)$属于$L$的其他非向外的子环$L'$，则有$r \in R^-(L')$。因为$L'$是非向外的，所以有$R^-(L') \subseteq R^-(L)$，这样就会得出$r \in R^-(L)$，导致矛盾。所以在这种情况下，我们可以把$head(R^-(C) \backslash R^-(L))$从当前子图中删除，从而得到更小的子图和子环，然后继续进行检测。
\end{enumerate}

对于给定的正规逻辑程序$P$及其环$L$，若$L$是$P$的基本环，那么算法\ref{algo_ElementaryLoop}将会返回$L$；
否则，算法\ref{algo_ElementaryLoop}将返回环$C$，其中，$C$满足$C \subset L$和$R^-(C) \subseteq R^-(L)$。

与Gebser等人\cite{gebser2005loops}提出的基本环识别算法不同的是，算法\ref{algo_ElementaryLoop}采取自顶向下的策略，先大环开始，逐步深入到小环。
需要注意的是，该算法每次都至少删除子图中的一个原子。所以，在最坏的情况下，算法\ref{algo_ElementaryLoop}将迭代$n^2$次，其中，$n$为环$L$中的原子数目。
另一方面，由于图的强连通分量可以在现行时间里面计算出，所以整个算法的时间复杂性为$O(n^2)$。

\section{析取逻辑程序的基本环}

上一节，我们从外部支持的角度，给出了正规逻辑程序的基本环的另一种定义。
本节，我们将把这种基于外部支持的定义拓展到析取逻辑程序。

\subsection{基本环的定义}

令$X$，$Y$为析取逻辑程序$P$中的原子集合，我们记$R_X^-(Y)=\lbrace r|r \in R^-(Y)\ and\ \\
head(r) \cap (X\backslash Y) \rbrace$，特别地，对于正规逻辑程序，$R_X^-(Y)=R^-(Y)$。

\begin{corollary}\label{chap3_corollary_dlp_el_clf}
	给定析取逻辑程序$P$，$L_1$和$L_2$为$P$中的环。如果$L_1 \subseteq L_2$且$R_(L_2)^-(L_1) \subseteq R^-(L_2)$，那么有$CLF(L_1,P) \supset CLF(L_2,P)$。
\end{corollary}

推论\ref{chap3_corollary_dlp_el_clf}是推论\ref{chap3_corollary_nlp_el_clf}的析取逻辑程序版本，其证明也是类似的，在这里就不给出了。
同样，由于$L_1$的环公式已经可以蕴含$L_2$的环公式了，$L_2$在回答集的计算中是可以被忽略的。

下面，我们从外部支持的角度给出原子集合是向外的的定义。

\begin{definition}[向外的]\label{chap3_definition_outbound}
	给定原子集合$C$和环$L$，如果$R_L^-(C) \nsubseteq R^-(L)$，那么我们称$C$在$L$中是向外的。
\end{definition}

根据定义\ref{chap2_definition_elementaryloop}和定义\ref{chap3_definition_outbound}，我们可以从外部支持的角度，重新定义基本环的概念。

\begin{definition}[析取逻辑程序的基本环]\label{chap3_definition_dlp_elementaryloop}
	给定析取逻辑程序$P$，环$L$是$P$的基本环，当且仅当不存在$L$的非空真子集$C$，使得$R_L^-(C) \subseteq R^-(L)$。
\end{definition}

\subsection{基本环的识别}

Gebser等人\cite{gebser2011elementary}在2011年证明了识别析取逻辑程序是coNP-complete的，这是计算机无法承受的。
基于定义\ref{chap3_definition_dlp_elementaryloop}，我们给出一个近似算法。该算法能在多项式时间内判断一个环$L$是否属于析取逻辑程序$P$的基本环的一个超集，记为$EL^*(P)$。

\RestyleAlgo{ruled}\LinesNumbered\input{algo/ElementaryLoopDLP.tex}

算法\ref{algo_ElementaryLoopDLP}的过程和算法\ref{algo_ElementaryLoop}相似，通过自顶向下的策略，考虑了环$L$的所有子环。对于每一个子环$C$，有两种情况：

\begin{enumerate}
	\item 如果$R_L^-(C) \subseteq R^-(L)$，那么根据定义\ref{chap3_definition_dlp_elementaryloop}，环$L$不是基本环；
	\item 如果$R_L^-(C) \nsubseteq R^-(L)$，那么对于任意规则$r \in R_L^-(C) \backslash R^-(L)$：
	\begin{enumerate}
		\item 若$|head(r) \cap C|=1$，则$head(r) \cap C$不可能在非向外的环$L'$里，其中，$L' \subset C$。否则，就会有$r \in R_L^-(L')$，而由$L'$是非向外的，有$R_L^-(L') \subseteq R^-(L)$，从而得出$r \in R_L^-(L)$，矛盾。此时，可以删除$r$；
		\item 若$|head(r) \cap C|>1$，则可能会有$L' \subseteq C$，使得$r \in R^-(L')$，$head(r) \cap (L \backslash L') \neq \emptyset$。此时，$L' \cap (head(r) \cap C) \neq \emptyset$，根据基本环的定义，不能删除$r$。然而，为了优化识别时间，该算法采取了近似的操作，在这里同样对$r$进行删除。
	\end{enumerate}
\end{enumerate}

给定任意析取逻辑程序$P$及其环$L$，算法\ref{algo_ElementaryLoopDLP}要么返回环$L$，要么返回环$C$，其中，$C \subset L$，$R_L^-(C) \subseteq R^-(L)$。
若返回环$C$，则$L$肯定不是基本环；若返回$L$，则有可能是基本环，也有可能不是。

算法\ref{algo_ElementaryLoopDLP}是算法\ref{algo_ElementaryLoop}的一样，每次迭代至少删除一个原子。
在最坏的情况下，整个算法迭代$n^2$次，$n$为环的原子的数目。
由于强连通分量可以在线性时间内求得，所以算法\ref{algo_ElementaryLoopDLP}的时间复杂度为$O(n^2)$。

\begin{example}\label{chap3_program_p5}
	考虑环$L=\lbrace p, q, r\rbrace$和析取逻辑程序$P_5$：
	\begin{eqnarray*}
	&& p \vee q \leftarrow r.\\
	&& p \vee r \leftarrow q.\\
	&& q \vee r \leftarrow p.\\
	&& r \leftarrow.
	\end{eqnarray*}	
	
	$EL^*(L,P_5)$返回$L$，事实上，$L$并不是$P$的基本环。因为对于$L'=\lbrace p, q\rbrace$：
	\begin{eqnarray*}
	&& R^-_L(L')=\emptyset \\
	&& R^-(L)=\lbrace r \leftarrow .\rbrace
	\end{eqnarray*}
	
	所以$R_L^-(L') \subseteq R^-(L)$。
\end{example}

记$EL(P)$为程序$P$的基本环的集合，$EL^*(P)$为使用算法\ref{algo_ElementaryLoopDLP}求得的环的集合，即$EL^*(P)=\lbrace L|L$是程序$P$的环且$EL^*(L,P)$返回$L\rbrace$。
那么，对于任意析取逻辑程序$P$，有$EL(P) \subseteq EL^*(P)$。特别地，如果$P$为正规逻辑程序，那么$EL(P)=EL^*(P)$。
另外，$HEF$程序虽然属于析取逻辑程序，但是由于它有性质$|head(r) \cap L| \le 1$，所以$EL(P)=EL^*(P)$。


\section{弱基本环}

尽管基本环和$HEF$程序的特性在回答集计算中很有用，但是识别它们的时间复杂度太高了。
本节，我们将提出基本环的一个超集，同时，给出多项式时间复杂度的识别算法。

\begin{corollary}\label{chap3_corollary_nlp_wel_clf}
	给定析取逻辑程序$P$，$L_1$和$L_2$为$P$中的环。如果$L_1 \subseteq L_2$且$R^-(L_1) \subseteq R^-(L_2)$，那么有$CLF(L_1,P) \supset CLF(L_2,P)$。
\end{corollary}
\begin{proof}
	对于环$L_1$，显然我们有$R_{L_2}^-(L_1) \subseteq R^-(L_1)$。
	又因为$R^-(L_1) \subseteq R^-(L_2)$，所以有$R_{L_2}^-(L_1) \subseteq R^-(L_1) \subseteq R^-(L_2)$，因此可得$R_{L_2}^-(L_1) \subseteq R^-(L_2)$。
	根据推论\ref{chap3_corollary_dlp_el_clf}，则有$CLF(L_1,P) \supset CLF(L_2,P)$。\quad
\end{proof}

现在，我们可以基于推论\ref{chap3_corollary_nlp_wel_clf}定义一个弱化版本的基本环，如下：
\begin{definition}[弱基本环]\label{chap3_definition_weak_elementary_loop}
	给定析取逻辑程序$P$，$L$为$P$的环。
	如果不存在$L$的非空真子集$C$，使得$R^-(C) \subseteq R^-(L)$，那么，我们称$L$是$P$的弱基本环(weak elementary loop)。
\end{definition}
\begin{corollary}
	给定析取逻辑程序$P$，$L$是$P$的环。如果$L$是$P$的基本环，那么$L$也是$P$的弱基本环。
\end{corollary}
\begin{proof}
	因为$L$是$P$的基本环，根据定义\ref{chap3_definition_dlp_elementaryloop}，对于$L$的任意非空真子集$C$，$R_L^-(C)$\\
	$\nsubseteq R^-(L)$，即存在规则$r \in R_L^-(C)$且$r \in R^-(L)$。
	由于$R_L^-(C) \subseteq R^-(C)$，所以$r \in R^-(C)$，由此可得$R^-(C) \nsubseteq R^-(L)$。根据定义\ref{chap3_definition_weak_elementary_loop}，$L$是$P$的弱基本环。\quad
\end{proof}
\begin{example}
	对于例\ref{chap2_program_p2}的程序$P_2$，环$L=\lbrace p, q, r\rbrace$是弱基本环，但不是基本环。
\end{example}

判断一个环是否程序的弱基本环是很容易的。
我们可以通过把算法\ref{algo_ElementaryLoopDLP}中的所有$R_L^-(C)$替换成$R^-(C)$，得到算法\ref{algo_WeakElementaryLoopDLP}，记为$WEL(L,P)$。
对于给定的程序$P$及其环$L$，若$L$是$P$的弱基本环，那么算法3将会返回$L$；否则，算法\ref{algo_WeakElementaryLoopDLP}将返回环$C$，
其中，$C$满足$C \subset L$且$R^-(C) \subseteq R^-(L)$。
显然，算法\ref{algo_WeakElementaryLoopDLP}跟算法\ref{algo_ElementaryLoopDLP}一样，时间复杂度为$O(n^2)$。

\RestyleAlgo{ruled}\LinesNumbered\input{algo/WeakElementaryLoop.tex}

记算程序$P$的所有弱基本环为$WEL(P)$。对于任意的析取逻辑程序$P$，我们有$EL(P) \subseteq EL^*(P) \subseteq WEL(P)$，
特别地，如果$P$是正规逻辑程序或$HEF$程序，那么$EL(P)=EL^*(P)=WEL(P)$。



\section{$HWEF$程序}

基于上节给出的弱基本环的概念，我们可以定义$HWEF$(Head-Weak-Elementary-loop-Free)程序。

\begin{definition}[$HWEF$程序]\label{chap3_definition_hwef}
	给定析取逻辑程序$P$，如果对于任意规则$r \in P$和任意弱基本环$L$，有$|head(r) \cap L| \le 1$，那么我们称$P$为$HWEF$程序。
\end{definition}

根据定义\ref{chap3_definition_hwef}和定义\ref{chap2_definition_hef}，我们可以知道$HWEF$程序同时也是$HEF$程序，所以$HWEF$程序$P$的回答集将会和$sh(P)$的一一对应。
然而，判断一个程序是否为$HWEF$程序的时间复杂性依然是coNP-complete。

虽然$HWEF$程序的识别很困难，但是弱基本环的一些性质可以帮助我们构造一个多项式的算法，用于判断程序是否属于$HWEF$程序的一个子类。
\begin{corollary}\label{chap3_corollary_weak_el}
	给定析取逻辑程序$P$，$L$都是$P$的环，$E$是$L$的非空真子集，即$E \subset L$。
	如果不存在规则$r \in P$，使得$body^+(r) \cap E \ne \emptyset$，$body^+(r) \cap (L\backslash E)=\emptyset$，$head(r) \cap (L \backslash E) \ne \emptyset$，那么$L$不是弱基本环。
\end{corollary}
\begin{proof}
	由于不存在这样的规则$r$，所以有：
	\begin{eqnarray*}
	&& L \backslash E \subset L\\
	&& R^-(L \backslash E) \subseteq R^-(L)
	\end{eqnarray*}
	
	即$L \backslash E$使得$L$不符合弱基本环的定义。\quad
\end{proof}

基于推论\ref{chap3_corollary_weak_el}，我们给出了算法\ref{algo_WeakElementaryLoopDLP2}，用来判断对于非空原子集$E$，是否不存在弱基本环$L$，$E \subset L$。
算法法\ref{algo_WeakElementaryLoopDLP2}从包含$E$的强连通分量($E \subseteq C$)出发，对每条体部正文字与$E$有交集的公式，删除$C$中与$body^+(r)\backslash E$相交的部分并求得残留图的强连通分量$C_r$；
判断$C_r$是否满足推论\ref{chap3_corollary_weak_el}的性质，若满足，则返回真。遍历所有公式后，若找不到符合要求的，则返回假。

\RestyleAlgo{ruled}\LinesNumbered\input{algo/WeakElementaryLoop2.tex}

对于给定的析取逻辑程序$P$和任意非空原子集$E$，算法法\ref{algo_WeakElementaryLoopDLP2}将在$O(m)$的时间内返回真或假，其中，$m$为$P$的规则数目。若返回假，那么表示不存在$P$的弱基本环$L$，使得$E \subset L$。

基于算法法\ref{algo_WeakElementaryLoopDLP}和算法法\ref{algo_WeakElementaryLoopDLP2}，我们给出算法5。算法5可以在多项式时间内判断给定程序是否属于$HWEF$程序的子类，记该子类为$HWEF^*$。
对于给定的析取逻辑程序$P$，首先利用程序中的规则，生成基为2的原子集合$E=\lbrace \lbrace a, b\rbrace |$there is a rule $r \in P$ s.t.$\lbrace a, b\rbrace \subseteq head(r)\rbrace$。
然后对于每个这样的原子集合$E$，使用算法法\ref{algo_WeakElementaryLoopDLP}判断其是否为弱基本环，如果$E$是弱基本环，那么就会有存在$r \in P$，使得$|head(r) \cap E|=2$，根据$HWEF$程序的定义，该程序不符合要求，此时，返回假；
如果$E$不是弱基本环，那么我们就使用算法法\ref{algo_WeakElementaryLoopDLP2}判断是否存在弱基本环$L$，使得$E \subset L$。
若算法法\ref{algo_WeakElementaryLoopDLP2}返回真，即可能存在弱基本环$L$，使得对某条规则$r$，有$|head(r) \cap E|\ge 2$，不符合$HWEF$程序的定义。
这种情况下，尽管只是有可能不符合，但是我们的处理是也返回假。

\RestyleAlgo{ruled}\LinesNumbered\input{algo/WeakElementaryLoop3.tex}

所以对于非$HWEF$程序，算法\ref{algo_WeakElementaryLoopDLP3}肯定返回假。然而，对于$HWEF$程序，则可能返回真，也可能返回假。由此可见，$HWEF^*$是$HWEF$的一个子类。
另一方面，算法\ref{algo_WeakElementaryLoopDLP3}只有一层循环，里面所调用的算法\ref{algo_WeakElementaryLoopDLP}和算法\ref{algo_WeakElementaryLoopDLP2}的时间复杂度分别为$O(n^2 )$和$O(m)$，所以算法\ref{algo_WeakElementaryLoopDLP3}的时间复杂度为$O(mn^2)$，其中，$m$为规则的个数，$n$为原子的个数。

\begin{example}\label{chap3_program_p5}
	考虑程序$P_5$：
	\begin{eqnarray*}
	&& p \vee q \leftarrow r.\\
	&& r \leftarrow p, q.\\
	&& p \leftarrow.
	\end{eqnarray*}
	
程序$P_5$有6个环：$\lbrace p\rbrace,\lbrace q\rbrace,\lbrace r\rbrace,\lbrace p,r\rbrace,\lbrace r,q\rbrace,\lbrace p,q,r\rbrace$。
由于$R^-(\lbrace p,q,r\rbrace)=\lbrace p \leftarrow.\rbrace$，$R^-(\lbrace ,q\rbrace)=\emptyset$。
$\lbrace p, q, r\rbrace$不是弱基本环，即弱基本环有：$\lbrace p\rbrace,\lbrace q\rbrace,\lbrace r\rbrace,\lbrace p,r\rbrace,\lbrace r,q\rbrace$。同时，$P_5$是$HWEF$程序。
但是，对于$E=\lbrace p,q\rbrace$，$EWEL(P_5,E)$返回真，所以$HWEF^*(P_5)$返回假。所以，$P_5$是$HWEF$程序，但不是$HWEF^*$程序。
\end{example}



\section{本章小结}
本章从外部支持的角度出发，介绍了基本环的另一种更直观的定义。
基于这种定义，本章给出了正规逻辑程序的基本环的识别算法和析取逻辑程序的近似识别算法。
针对析取逻辑程序的基本环的识别效率低这一难题，本章还提出了弱基本环的概念，同时，还给出了弱基本环的识别算法。
在本章的最后部分，我们还提出了$HWEF$程序的概念，随后，我们还讨论了一个可以识别$HWEF$程序的一个子集$HWEF^*$程序的算法。


